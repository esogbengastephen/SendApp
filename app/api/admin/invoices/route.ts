import { NextRequest, NextResponse } from "next/server";
import { supabaseAdmin } from "@/lib/supabase";

type InvoiceRow = {
  id?: string;
  invoice_number?: string;
  user_id?: string | null;
  amount?: number | string;
  currency?: string;
  crypto_chain_id?: string | null;
  description?: string | null;
  customer_name?: string | null;
  customer_email?: string | null;
  customer_phone?: string | null;
  status?: string;
  due_date?: string | null;
  paid_at?: string | null;
  transaction_id?: string | null;
  paystack_reference?: string | null;
  created_at?: string;
  updated_at?: string;
};

/**
 * Fetch all invoices for admin. Uses supabaseAdmin to bypass RLS.
 * Returns details of every invoice generated by users.
 * Optional ?status= filter: pending | paid | expired | cancelled
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const status = searchParams.get("status");

    let query = supabaseAdmin
      .from("invoices")
      .select("*")
      .order("created_at", { ascending: false })
      .limit(500);

    if (status && ["pending", "paid", "expired", "cancelled"].includes(status)) {
      query = query.eq("status", status);
    }

    const { data: allInvoices, error: invError } = await query;

    if (invError) {
      console.error("[Admin Invoices] Supabase error:", invError);
      const msg = String(invError.message || invError);
      const isMissingTable = /relation "invoices" does not exist|does not exist/i.test(msg);
      const isRls = /policy|RLS|row-level security/i.test(msg);
      return NextResponse.json(
        {
          success: false,
          error: isMissingTable
            ? "Invoices table not found. Run the invoices migration (019_create_invoices_table.sql) in Supabase."
            : isRls
            ? "Admin access denied. Set SUPABASE_SERVICE_ROLE_KEY in .env.local for admin API."
            : "Failed to fetch invoices",
          details: msg,
        },
        { status: 500, headers: { "Cache-Control": "private, no-store" } }
      );
    }

    const invoices: InvoiceRow[] = Array.isArray(allInvoices) ? allInvoices : [];

    if (invoices.length === 0) {
      return NextResponse.json(
        { success: true, invoices: [] },
        { headers: { "Cache-Control": "private, no-store" } }
      );
    }

    const userIds = [...new Set(invoices.map((i) => i.user_id).filter(Boolean) as string[])];
    const { data: users } = await supabaseAdmin
      .from("users")
      .select("id, email")
      .in("id", userIds);
    const emailByUserId = (users || []).reduce<Record<string, string>>((acc, u) => {
      if (u?.id && u?.email) acc[u.id] = u.email;
      return acc;
    }, {});

    const list = invoices.map((i) => ({
      id: i.id ?? "",
      invoiceNumber: i.invoice_number ?? "",
      userId: i.user_id ?? null,
      merchantEmail: (i.user_id && emailByUserId[i.user_id]) || "â€”",
      amount: typeof i.amount === "number" ? i.amount : parseFloat(String(i.amount ?? "0")),
      currency: i.currency ?? "NGN",
      cryptoChainId: i.crypto_chain_id ?? null,
      description: i.description ?? null,
      customerName: i.customer_name ?? null,
      customerEmail: i.customer_email ?? null,
      customerPhone: i.customer_phone ?? null,
      status: i.status ?? "pending",
      dueDate: i.due_date ?? null,
      paidAt: i.paid_at ?? null,
      transactionId: i.transaction_id ?? null,
      paystackReference: i.paystack_reference ?? null,
      createdAt: i.created_at ?? "",
      updatedAt: i.updated_at ?? "",
    }));

    return NextResponse.json(
      { success: true, invoices: list },
      { headers: { "Cache-Control": "private, no-store" } }
    );
  } catch (error: unknown) {
    const details = error instanceof Error ? error.message : String(error);
    console.error("[Admin Invoices] Error:", details);
    return NextResponse.json(
      { success: false, error: "Failed to fetch invoices", details },
      { status: 500, headers: { "Cache-Control": "private, no-store" } }
    );
  }
}
