import { NextRequest, NextResponse } from "next/server";
import { isAdminWallet } from "@/lib/supabase";
import { supabaseAdmin } from "@/lib/supabase";
import { createWalletClient, createPublicClient, http, formatUnits, parseUnits } from "viem";
import { base } from "viem/chains";
import { privateKeyToAccount } from "viem/accounts";
import { BASE_RPC_URL, SEND_TOKEN_ADDRESS } from "@/lib/constants";
import { generateUserOfframpWallet, generateOfframpWallet } from "@/lib/offramp-wallet";

const ERC20_ABI = [
  {
    constant: true,
    inputs: [{ name: "_owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    type: "function",
  },
  {
    constant: false,
    inputs: [
      { name: "_to", type: "address" },
      { name: "_value", type: "uint256" },
    ],
    name: "transfer",
    outputs: [{ name: "", type: "bool" }],
    type: "function",
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", type: "uint8" }],
    type: "function",
  },
] as const;

/**
 * Recover SEND tokens from a wallet using its private key (Admin only)
 * POST /api/admin/offramp/recover-tokens
 * 
 * Body: {
 *   adminWallet: string,
 *   walletAddress: string,
 *   privateKey: string,  // Private key for the wallet
 *   recipientAddress: string  // Where to send the tokens
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { adminWallet, walletAddress, privateKey, recipientAddress } = body;

    // Verify admin access
    if (!adminWallet) {
      return NextResponse.json(
        { success: false, error: "Admin wallet address required" },
        { status: 400 }
      );
    }

    const isAdmin = await isAdminWallet(adminWallet);
    if (!isAdmin) {
      return NextResponse.json(
        { success: false, error: "Admin access required" },
        { status: 403 }
      );
    }

    if (!walletAddress || !recipientAddress) {
      return NextResponse.json(
        {
          success: false,
          error: "walletAddress and recipientAddress are required",
        },
        { status: 400 }
      );
    }

    // Try to find the transaction for this wallet
    const { data: transaction } = await supabaseAdmin
      .from("offramp_transactions")
      .select("*")
      .eq("unique_wallet_address", walletAddress.toLowerCase())
      .order("created_at", { ascending: false })
      .limit(1)
      .maybeSingle();

    let account;
    let walletSource = "";

    // If private key is provided, use it directly
    if (privateKey) {
      let cleanPrivateKey = privateKey.trim().replace(/\s/g, "");
      if (!cleanPrivateKey.startsWith("0x")) {
        cleanPrivateKey = `0x${cleanPrivateKey}`;
      }

      if (cleanPrivateKey.length !== 66) {
        return NextResponse.json(
          {
            success: false,
            error: "Invalid private key format. Must be 66 characters (0x + 64 hex)",
          },
          { status: 400 }
        );
      }

      try {
        account = privateKeyToAccount(cleanPrivateKey as `0x${string}`);
        walletSource = "provided_private_key";
      } catch (error: any) {
        return NextResponse.json(
          {
            success: false,
            error: "Invalid private key",
            details: error.message,
          },
          { status: 400 }
        );
      }

      // Verify the private key matches the wallet address
      if (account.address.toLowerCase() !== walletAddress.toLowerCase()) {
        return NextResponse.json(
          {
            success: false,
            error: "Private key does not match the provided wallet address",
            providedAddress: walletAddress,
            derivedAddress: account.address,
          },
          { status: 400 }
        );
      }
    } else {
      // Try to derive the wallet from the transaction
      if (!transaction) {
        return NextResponse.json(
          {
            success: false,
            error: "No transaction found for this wallet and no private key provided. Cannot recover tokens without private key.",
            walletAddress: walletAddress.toLowerCase(),
            hint: "Provide the privateKey parameter, or ensure the wallet was generated by the system and the transaction exists.",
          },
          { status: 400 }
        );
      }

      // Try old transaction-based method first
      try {
        const oldWallet = generateOfframpWallet(transaction.transaction_id);
        if (oldWallet.address.toLowerCase() === walletAddress.toLowerCase()) {
          account = privateKeyToAccount(oldWallet.privateKey as `0x${string}`);
          walletSource = "old_transaction_based";
          console.log(`[Recover Tokens] Found wallet using old transaction-based method`);
        }
      } catch (error) {
        // Old method failed, try new user-based method
      }

      // If old method didn't work, try new user-based method
      if (!account) {
        try {
          const userIdentifier = transaction.user_id || transaction.user_email || `guest_${transaction.user_account_number}`;
          const newWallet = generateUserOfframpWallet(userIdentifier);
          if (newWallet.address.toLowerCase() === walletAddress.toLowerCase()) {
            account = privateKeyToAccount(newWallet.privateKey as `0x${string}`);
            walletSource = "new_user_based";
            console.log(`[Recover Tokens] Found wallet using new user-based method`);
          }
        } catch (error) {
          // New method also failed
        }
      }

      if (!account) {
        return NextResponse.json(
          {
            success: false,
            error: "Cannot derive wallet private key from master mnemonic. The wallet may have been created with a different mnemonic.",
            walletAddress: walletAddress.toLowerCase(),
            transactionId: transaction.transaction_id,
            hint: "Provide the privateKey parameter to manually specify the private key.",
          },
          { status: 400 }
        );
      }
    }

    const walletClient = createWalletClient({
      account,
      chain: base,
      transport: http(BASE_RPC_URL),
    });

    const publicClient = createPublicClient({
      chain: base,
      transport: http(BASE_RPC_URL),
    });

    // Check SEND token balance
    const balance = (await publicClient.readContract({
      address: SEND_TOKEN_ADDRESS as `0x${string}`,
      abi: ERC20_ABI,
      functionName: "balanceOf",
      args: [walletAddress.toLowerCase() as `0x${string}`],
    })) as bigint;

    if (balance === BigInt(0)) {
      return NextResponse.json(
        {
          success: false,
          error: "No SEND tokens found in this wallet",
          walletAddress: walletAddress.toLowerCase(),
        },
        { status: 400 }
      );
    }

    const decimals = 18; // SEND has 18 decimals
    const balanceFormatted = formatUnits(balance, decimals);

    console.log(`[Recover Tokens] Found ${balanceFormatted} SEND tokens in ${walletAddress}`);

    // Check ETH balance for gas
    const ethBalance = await publicClient.getBalance({
      address: walletAddress.toLowerCase() as `0x${string}`,
    });

    const minGasRequired = parseUnits("0.0001", 18); // Minimum gas needed
    if (ethBalance < minGasRequired) {
      return NextResponse.json(
        {
          success: false,
          error: "Insufficient ETH for gas fees",
          ethBalance: formatUnits(ethBalance, 18),
          required: formatUnits(minGasRequired, 18),
          hint: "Please fund the wallet with at least 0.0001 ETH for gas",
        },
        { status: 400 }
      );
    }

    // Transfer SEND tokens to recipient
    console.log(`[Recover Tokens] Transferring ${balanceFormatted} SEND to ${recipientAddress}`);

    const txHash = await walletClient.writeContract({
      address: SEND_TOKEN_ADDRESS as `0x${string}`,
      abi: ERC20_ABI,
      functionName: "transfer",
      args: [recipientAddress.toLowerCase() as `0x${string}`, balance],
    });

    console.log(`[Recover Tokens] Transaction sent: ${txHash}`);

    // Wait for confirmation
    const receipt = await publicClient.waitForTransactionReceipt({
      hash: txHash,
    });

    if (receipt.status === "success") {
      return NextResponse.json({
        success: true,
        message: "SEND tokens recovered successfully",
        walletAddress: walletAddress.toLowerCase(),
        recipientAddress: recipientAddress.toLowerCase(),
        amount: balanceFormatted,
        amountRaw: balance.toString(),
        txHash: txHash,
        blockNumber: receipt.blockNumber.toString(),
        walletSource: walletSource || "unknown",
      });
    } else {
      return NextResponse.json(
        {
          success: false,
          error: "Transaction failed",
          txHash: txHash,
        },
        { status: 500 }
      );
    }
  } catch (error: any) {
    console.error("[Recover Tokens] Error:", error);
    return NextResponse.json(
      {
        success: false,
        error: error.message || "Internal server error",
        details: error.stack,
      },
      { status: 500 }
    );
  }
}

